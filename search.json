[{"path":"https://oist.github.io/NEXTNetR/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU Lesser General Public License","title":"GNU Lesser General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed. version GNU Lesser General Public License incorporates terms conditions version 3 GNU General Public License, supplemented additional permissions listed .","code":""},{"path":"https://oist.github.io/NEXTNetR/LICENSE.html","id":"id_0-additional-definitions","dir":"","previous_headings":"","what":"0. Additional Definitions","title":"GNU Lesser General Public License","text":"used herein, “License” refers version 3 GNU Lesser General Public License, “GNU GPL” refers version 3 GNU General Public License. “Library” refers covered work governed License, Application Combined Work defined . “Application” work makes use interface provided Library, otherwise based Library. Defining subclass class defined Library deemed mode using interface provided Library. “Combined Work” work produced combining linking Application Library. particular version Library Combined Work made also called “Linked Version”. “Minimal Corresponding Source” Combined Work means Corresponding Source Combined Work, excluding source code portions Combined Work , considered isolation, based Application, Linked Version. “Corresponding Application Code” Combined Work means object code /source code Application, including data utility programs needed reproducing Combined Work Application, excluding System Libraries Combined Work.","code":""},{"path":"https://oist.github.io/NEXTNetR/LICENSE.html","id":"id_1-exception-to-section-3-of-the-gnu-gpl","dir":"","previous_headings":"","what":"1. Exception to Section 3 of the GNU GPL","title":"GNU Lesser General Public License","text":"may convey covered work sections 3 4 License without bound section 3 GNU GPL.","code":""},{"path":"https://oist.github.io/NEXTNetR/LICENSE.html","id":"id_2-conveying-modified-versions","dir":"","previous_headings":"","what":"2. Conveying Modified Versions","title":"GNU Lesser General Public License","text":"modify copy Library, , modifications, facility refers function data supplied Application uses facility (argument passed facility invoked), may convey copy modified version: ) License, provided make good faith effort ensure , event Application supply function data, facility still operates, performs whatever part purpose remains meaningful, b) GNU GPL, none additional permissions License applicable copy.","code":""},{"path":"https://oist.github.io/NEXTNetR/LICENSE.html","id":"id_3-object-code-incorporating-material-from-library-header-files","dir":"","previous_headings":"","what":"3. Object Code Incorporating Material from Library Header Files","title":"GNU Lesser General Public License","text":"object code form Application may incorporate material header file part Library. may convey object code terms choice, provided , incorporated material limited numerical parameters, data structure layouts accessors, small macros, inline functions templates (ten fewer lines length), following: ) Give prominent notice copy object code Library used Library use covered License. b) Accompany object code copy GNU GPL license document.","code":""},{"path":"https://oist.github.io/NEXTNetR/LICENSE.html","id":"id_4-combined-works","dir":"","previous_headings":"","what":"4. Combined Works","title":"GNU Lesser General Public License","text":"may convey Combined Work terms choice , taken together, effectively restrict modification portions Library contained Combined Work reverse engineering debugging modifications, also following: ) Give prominent notice copy Combined Work Library used Library use covered License. b) Accompany Combined Work copy GNU GPL license document. c) Combined Work displays copyright notices execution, include copyright notice Library among notices, well reference directing user copies GNU GPL license document. d) one following: 0) Convey Minimal Corresponding Source terms License, Corresponding Application Code form suitable , terms permit, user recombine relink Application modified version Linked Version produce modified Combined Work, manner specified section 6 GNU GPL conveying Corresponding Source. 1) Use suitable shared library mechanism linking Library. suitable mechanism one () uses run time copy Library already present user’s computer system, (b) operate properly modified version Library interface-compatible Linked Version. e) Provide Installation Information, otherwise required provide information section 6 GNU GPL, extent information necessary install execute modified version Combined Work produced recombining relinking Application modified version Linked Version. (use option 4d0, Installation Information must accompany Minimal Corresponding Source Corresponding Application Code. use option 4d1, must provide Installation Information manner specified section 6 GNU GPL conveying Corresponding Source.)","code":""},{"path":"https://oist.github.io/NEXTNetR/LICENSE.html","id":"id_5-combined-libraries","dir":"","previous_headings":"","what":"5. Combined Libraries","title":"GNU Lesser General Public License","text":"may place library facilities work based Library side side single library together library facilities Applications covered License, convey combined library terms choice, following: ) Accompany combined library copy work based Library, uncombined library facilities, conveyed terms License. b) Give prominent notice combined library part work based Library, explaining find accompanying uncombined form work.","code":""},{"path":"https://oist.github.io/NEXTNetR/LICENSE.html","id":"id_6-revised-versions-of-the-gnu-lesser-general-public-license","dir":"","previous_headings":"","what":"6. Revised Versions of the GNU Lesser General Public License","title":"GNU Lesser General Public License","text":"Free Software Foundation may publish revised /new versions GNU Lesser General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Library received specifies certain numbered version GNU Lesser General Public License “later version” applies , option following terms conditions either published version later version published Free Software Foundation. Library received specify version number GNU Lesser General Public License, may choose version GNU Lesser General Public License ever published Free Software Foundation. Library received specifies proxy can decide whether future versions GNU Lesser General Public License shall apply, proxy’s public statement acceptance version permanent authorization choose version Library.","code":""},{"path":"https://oist.github.io/NEXTNetR/articles/NEXTNetR.html","id":"loading-the-nextnetr-package","dir":"Articles","previous_headings":"","what":"Loading the NEXTNetR package","title":"Basic Simulations of Epidemics","text":"start loading NEXTNetR package. package already installed, see website installation instructions. also load ggplot2 ggpubr packages plotting set nice theme.","code":"library(NEXTNetR) library(ggplot2) library(ggpubr) theme_set(theme_pubr())"},{"path":"https://oist.github.io/NEXTNetR/articles/NEXTNetR.html","id":"creating-and-inspecting-networks","dir":"Articles","previous_headings":"","what":"Creating and inspecting networks","title":"Basic Simulations of Epidemics","text":"Next create network object. see full list network types supported NEXTNetR, type help(network_types). , create random Erdős–Rényi network given size, .e. given number nodes. Erdős–Rényi networks, possible link probability exist independent links. probability computed nodes specified average degree (.e. number neighbours). object nw now represents specific network. can inspect network using functions listed help(network_properties). example, can query number neighbours node 371 knowing degree can query neighbours node 371. inspection functions vectorized can query multiple nodes . example, plot degree distribution histogram compare theoretically predicted Poisson distribution (dashed blue line) can simply ","code":"nw <- erdos_renyi_network(size=1e5, avg_degree=5) degree <- network_outdegree(nw, 371) print(degree) #> [1] 6 network_neighbour(nw, 371, 1:degree) #> [1] 18386 32383 63810 66115 83635 88963 N <- network_size(nw) ggplot(data.frame(degree=network_outdegree(nw, 1:N))) +   geom_histogram(aes(x=degree, y=after_stat(count)),                  binwidth=1, fill='darkgrey', color=NA) +   geom_function(fun=function(n) N * dpois(round(n), 5),                 n=1000, color='blue', linetype=\"dashed\", linewidth=0.5)"},{"path":"https://oist.github.io/NEXTNetR/articles/NEXTNetR.html","id":"creating-and-inspecting-time-distributions","dir":"Articles","previous_headings":"","what":"Creating and inspecting time distributions","title":"Basic Simulations of Epidemics","text":"can start simulation, next create time distributions represent time takes transmit disease across link, time takes infected node recover. chose log-normal distribution infection. specifying p_infinity = 0.1, modify infection time distribution produce infinite infection time (.e. actual infection) 10% cases; means neighbours infected node 90% chance becoming infected eventually. time distribution objects mainly useful epidemic simulations, can also used similed R’s built-random distributions, see help(time_functions). can, example, plot distribution’s density survival function.","code":"infection_time <- lognormal_time(mean=6, var=30, p_infinity = 0.1) ggarrange(   ggplot() +     lims(x=c(0, 25)) + labs(x='time', y='density') +     geom_function(fun=time_density, n=1000,                   args=list(timedistribution=infection_time)),   ggplot() +     lims(x=c(0, 25), y=c(0,1)) + labs(x='time', y='survival') +     geom_function(fun=time_survivalprobability, n=1000,                   args=list(timedistribution=infection_time)),   ncol=1 )"},{"path":"https://oist.github.io/NEXTNetR/articles/NEXTNetR.html","id":"creating-and-running-simulations","dir":"Articles","previous_headings":"","what":"Creating and running simulations","title":"Basic Simulations of Epidemics","text":"run simulation, now create simulation object binds together network infection time distribution created Finally, add initial infection get epidemic going start simulation, telling run either time 100 50,000 nodes infected. Running simulation returns data.frame listing events occurred. can use plot size epidemic time.  Simulations can continued calling simulation_run . continue simulation time 50, plot full trajectory, must combine events reported first call simulation_run events reported second call,","code":"sim <- simulation(nw=nw, psi=infection_time) simulation_addinfections(sim, nodes=c(1), times=c(0.0)) events <- simulation_run(sim, stop=list(time=100, total_infected=50e3)) ggplot(events) +   geom_line(aes(x=time, y=infected)) events2 <- simulation_run(sim, stop=list(time=50)) ggplot(rbind(events, events2)) +   geom_line(aes(x=time, y=infected))"},{"path":"https://oist.github.io/NEXTNetR/articles/NEXTNetR.html","id":"adding-a-recovery-or-reset-time","dir":"Articles","previous_headings":"","what":"Adding a recovery (or reset) time","title":"Basic Simulations of Epidemics","text":"previous simulation, nodes infected stayed infected indefinitely. now add recovery time nodes eventually return original state. Note recovery also implies nodes become susceptible reinfection; better term may therefore reset. recovery time distribution, pick weibull distribution  run simulation, create simulation object, time specifying recovery time rho parameter. trajectory now shows wave-like pattern","code":"recovery_time <- weibull_time(shape=5, scale=50) ggplot() +   lims(x=c(0, 100)) + labs(x='time', y='density') +   geom_function(fun=time_density,                 args=list(timedistribution=recovery_time)) sim <- simulation(nw=nw, psi=infection_time, rho=recovery_time) simulation_addinfections(sim, nodes=c(1), times=c(0.0)) events <- simulation_run(sim, stop=list(time=300, total_infected=300e3)) ggplot(events) +   geom_line(aes(x=time, y=infected))"},{"path":"https://oist.github.io/NEXTNetR/articles/custom_time_distributions_cpp.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Custom time distributions (using C++)","text":"NEXTNetR provides set built-time distributions can used transmission recovery times simulations, see help(time_distributions). Additional distributions can defined users either R C++ code. discuss C++ solution, significantly (orders magnitudes!) faster, complex. slower simpler pure R solution, see vignette(\"custom_time_distributions_r\").","code":""},{"path":"https://oist.github.io/NEXTNetR/articles/custom_time_distributions_cpp.html","id":"loading-the-nextnetr-package","dir":"Articles","previous_headings":"","what":"Loading the NEXTNetR package","title":"Custom time distributions (using C++)","text":"start loading required packages. NEXTNetRis already installed, see website installation instructions. conveniently mix C++ R code, use cpp11 package together decor. implement new distribution, C++ code must able see global symbols related transmission_time class defined NEXTNetR package. Unfortunately, R packages usually loaded way prevents . work around , therefore load NEXTNetR’s shared library manually importing package. way, can specify local=TRUE load library make symbols globally visible. Note may required platforms. Finally, also load ggplot2 ggpubr packages plotting set nice theme.","code":"# Make sure the NEXTNetR shared library is loaded with local=FALSE # This has to be done *before* library(NEXTNetR) nnR.dir <- find.package(\"NEXTNetR\") nnR.lib <- if (nzchar(.Platform$r_arch)) {   file.path(nnR.dir, \"libs\", .Platform$r_arch,             paste0(\"NEXTNetR\", .Platform$dynlib.ext)) } else {   file.path(nnR.dir, \"libs\",             paste0(\"NEXTNetR\", .Platform$dynlib.ext)) } dyn.load(nnR.lib, local=FALSE, now=TRUE)  # Now we may load NEXTNetR library(NEXTNetR)  # For cpp_source() library(cpp11) library(decor)  # For plotting library(ggplot2) library(ggpubr) theme_set(theme_pubr())"},{"path":"https://oist.github.io/NEXTNetR/articles/custom_time_distributions_cpp.html","id":"implementing-a-custom-time-distribution-in-c","dir":"Articles","previous_headings":"","what":"Implementing a custom time distribution in C++","title":"Custom time distributions (using C++)","text":"implement custom time distribution, implement time_distribution interface (.e. abstract base class) defined NEXTNet C++ library. minimal set functions implementation interface must provide two functions provided, random samples distribution generated generating uniformly distribution random value 0 1 computing corresponding quantile. Since override quantile function, quantile computed numerically inverting survival function using bisection, slow. efficient way generating samples, thus want also override sample function function must sample derived distribution conditioned \\(t\\) modulated \\(m\\), see help(time_functions) discussion parameters. Often, generating samples unmodified distribution, .e. \\(t=0\\) \\(m=1\\) considerably simpler. Since , unweighted networks, also far common case, typical strategy optimize case, .e. Finally, quantiles can computed efficiently inverting survival function, also override quantile function","code":"virtual double density(interval_t tau) const; virtual double survivalprobability(interval_t tau) const; virtual interval_t sample(rng_t &, interval_t t, double m) const; virtual interval_t sample(rng_t &rng, interval_t t, double m) const override {   if ((t == 0.0) && (m == 1.0)) {     // generate sample from base distribution     return ...   }   // Use numeric inversion of the survival function for the general case   return transmission_time::sample(rng, t, m); } virtual interval_t survivalquantile(double u) const;"},{"path":"https://oist.github.io/NEXTNetR/articles/custom_time_distributions_cpp.html","id":"a-mixture-of-existing-distributions","dir":"Articles","previous_headings":"Implementing a custom time distribution in C++","what":"A mixture of existing distributions","title":"Custom time distributions (using C++)","text":"following file mixture_time.cpp implements mixture \\(n\\) arbitrary time distributions given weights. defines class mixture_time_impl derives abstract base class time_distribution implements sample, survivalprobability, density methods. create mixture distributions, provides function mixture_time converts parameters appropriately returns instance mixture_time_impl transmission_time_R (type encapsulates C++ time distribution objects can passed R). now compile function externally load resulting shared library R. However, cpp11 provides simpler way form cpp_source() function. function takes care compiling, linking loading code, makes functions marked [[cpp11::register]] available R. can now use mixture_time use distributions provided NEXTNetR. example, create mixture exponential distribution mean 5 log-normal distribution mean 200 variance 500, weighted 30% samples come exponential distribution, can test sample newly created distribution using time_sample use time_density time_survivalprobability compare distribution samples (blue) theoretical distribution (black) check everything works correctly","code":"/* mixture_time.cpp */  #include <random> #include <cpp11.hpp> #include <cpp11/function.hpp>  #include \"NEXTNetR/NEXTNetR_types.h\" #include \"nextnet/random.h\"  using namespace cpp11;  struct mixture_time_impl : public virtual transmission_time {   virtual interval_t sample(rng_t &rng, interval_t t, double m) const override {     if ((t == 0.0) && (m == 1.0))       return times.at(pick(rng)).get()->sample(rng, 0.0, 1.0);     return transmission_time::sample(rng, t, m);   }      virtual double survivalprobability(interval_t tau) const override {     double p = 0.0;     for(std::size_t i=0; i < times.size(); ++i)       p += weights.at(i) * times.at(i).get()->survivalprobability(tau);     return p;   }    virtual double density(interval_t tau) const override {     double p = 0.0;     for(std::size_t i=0; i < times.size(); ++i)       p += weights.at(i) * times.at(i).get()->density(tau);     return p;   }   std::vector<transmission_time_R> times;   std::vector<double> weights;   mutable std::discrete_distribution<std::size_t> pick; };  [[cpp11::linking_to(\"BH\")]] [[cpp11::linking_to(\"NEXTNetR\")]] [[cpp11::register]] SEXP mixture_time(list times, doubles weights) {   // Validate parameters   if (times.size() != weights.size())     throw std::runtime_error(\"number of distributions and weights must agree\");    // Create object   auto r = std::make_unique<mixture_time_impl>();      // Set individual distributions and weights   r->times.reserve(times.size());   r->weights.reserve(times.size());   double ws = 0.0;   for(R_xlen_t i=0; i < times.size(); ++i)       ws += weights[i];   for(R_xlen_t i=0; i < times.size(); ++i) {     r->times.push_back((transmission_time_R)times[i]);     r->weights.push_back(weights[i] / ws);   }   r->pick = std::discrete_distribution<std::size_t>(       weights.begin(), weights.end());    // Return created object   return transmission_time_R(r.release()); } cpp_source('mixture_time.cpp', dir=\"/tmp/test\", clean=FALSE, cxx_std=\"CXX17\") psi <- mixture_time(times=list(exponential_time(1/10),                     lognormal_time(200, 500)), weights=c(0.3, 0.7)) samples <- time_sample(1e5, psi, t=10, m=2) samples.ecdf <- ecdf(samples) ggarrange(   ggplot() +     lims(x=c(0, 300)) +     geom_histogram(data=data.frame(time=samples),                    aes(x=time, y=after_stat(density)),                    binwidth=2, fill=\"cornflowerblue\") +     geom_function(fun=time_density, n=1000,                   args=list(timedistribution=psi, t=10, m=2)),   ggplot() +     lims(x=c(0, 300), y=c(0,1)) + labs(x='time', y='survival') +     geom_function(fun=function(x) 1 - samples.ecdf(x),                   color=\"cornflowerblue\", linewidth=2) +     geom_function(fun=time_survivalprobability, n=1000,                   args=list(timedistribution=psi, t=10, m=2)),   ncol=1 )"},{"path":"https://oist.github.io/NEXTNetR/articles/custom_time_distributions_cpp.html","id":"simulations-using-our-custom-distribution","dir":"Articles","previous_headings":"","what":"Simulations using our custom distribution","title":"Custom time distributions (using C++)","text":"custom distribution simulations way built-distributions, see vignette(NEXTNetR) step step explanation ","code":"nw <- erdos_renyi_network(1e5, 5) sim <- simulation(nw, psi) simulation_addinfections(sim, nodes=c(1), times=c(0.0)) events <- simulation_run(sim, stop=list(total_infected=300e3)) ggplot(events) +   geom_line(aes(x=time, y=infected))"},{"path":"https://oist.github.io/NEXTNetR/articles/custom_time_distributions_r.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Custom time distributions (using pure R)","text":"NEXTNetR provides set built-time distributions can used transmission recovery times simulations, see help(time_distributions). Additional distributions can defined users either R C++ code. discuss simpler much (order magnitude!) slower R solution. See vignette(\"custom_time_distributions_cpp\") faster complex C++ solution.","code":""},{"path":"https://oist.github.io/NEXTNetR/articles/custom_time_distributions_r.html","id":"loading-the-nextnetr-package","dir":"Articles","previous_headings":"","what":"Loading the NEXTNetR package","title":"Custom time distributions (using pure R)","text":"start loading NEXTNetR package. package already installed, see website installation instructions. also load ggplot2 ggpubr packages plotting set nice theme.","code":"library(NEXTNetR) library(ggplot2) library(ggpubr) theme_set(theme_pubr())"},{"path":"https://oist.github.io/NEXTNetR/articles/custom_time_distributions_r.html","id":"implementing-a-custom-time-distribution-in-pure-r","dir":"Articles","previous_headings":"","what":"Implementing a custom time distribution in pure R","title":"Custom time distributions (using pure R)","text":"implement custom time distribution, use userdefined_time(). function allows us provide arbitrary R functions implement functions listed help(time_functions) distribution. function must take either single argument tau three arguments tau, t m. least two functions survival density must provided. providing single-argument functions, signal NEXTNet implement base distribution leave NEXTNet derive conditioned modulated version distribution , see discussions help(time_functions) help(userdefined_time). use userdefined_time() create function mixture_time returns mixture distributions listed times weights weights. now use newly created mixture_time function create mixture exponential distribution mean 5 log-normal distribution mean 200 variance 500, weighted 30% samples come exponential distribution. test sample newly created distribution using time_sample use time_density time_survivalprobability compare distribution samples (blue) theoretical distribution (black) check everything works correctly","code":"mixture_time <- function(times, weights) {   ud_time <- NULL   ud_time <- userdefined_time(     survival=function(tau)       sum(sapply(times, time_survivalprobability, tau) * weights),     density=function(tau)       sum(sapply(times, time_density, tau) * weights),     sample=function() {       i <- sample.int(n=length(weights), prob = weights, size=1)       return(time_sample(1, times[[i]]))     },   ) } psi <- mixture_time(times=list(exponential_time(1/10),                     lognormal_time(200, 500)), weights=c(0.3, 0.7)) samples <- time_sample(1e3, psi, t=10, m=2) samples.ecdf <- ecdf(samples) ggarrange(   ggplot() +     lims(x=c(0, 300)) +     geom_histogram(data=data.frame(time=samples),                    aes(x=time, y=after_stat(density)),                    binwidth=2, fill=\"cornflowerblue\") +     geom_function(fun=time_density, n=1000,                   args=list(timedistribution=psi, t=10, m=2)),   ggplot() +     lims(x=c(0, 300), y=c(0,1)) + labs(x='time', y='survival') +     geom_function(fun=function(x) 1 - samples.ecdf(x),                   color=\"cornflowerblue\", linewidth=2) +     geom_function(fun=time_survivalprobability, n=1000,                   args=list(timedistribution=psi, t=10, m=2)),   ncol=1 )"},{"path":"https://oist.github.io/NEXTNetR/articles/custom_time_distributions_r.html","id":"simulations-using-our-custom-distribution","dir":"Articles","previous_headings":"","what":"Simulations using our custom distribution","title":"Custom time distributions (using pure R)","text":"custom distribution simulations way built-distributions, see vignette(\"NEXTNetR\") step step explanation ","code":"nw <- erdos_renyi_network(1e3, 5) sim <- simulation(nw, psi) simulation_addinfections(sim, nodes=c(1), times=c(0.0)) events <- simulation_run(sim, stop=list(total_infected=300e3)) ggplot(events) +   geom_line(aes(x=time, y=infected))"},{"path":"https://oist.github.io/NEXTNetR/articles/empirical_networks.html","id":"loading-the-nextnetr-package","dir":"Articles","previous_headings":"","what":"Loading the NEXTNetR package","title":"Empirical Networks","text":"start loading NEXTNetR package. package already installed, see website installation instructions. also load ggplot2 ggpubr packages plotting set nice theme.","code":"library(NEXTNetR) library(ggplot2) library(ggpubr) theme_set(theme_pubr())"},{"path":"https://oist.github.io/NEXTNetR/articles/empirical_networks.html","id":"defining-networks","dir":"Articles","previous_headings":"","what":"Defining networks","title":"Empirical Networks","text":"create arbitrary, user-defined networks defined adjacency lists, NEXTNetR provides adjacencylist_network() adjacencylist_weightednetwork(). first use adjacencylist_network() create undirected network nodes 1, 2, 3, 4 form clique (.e. node linked others) node 5 linked nodes 1 2 node 6 nodes 3 4. Note since network undirected, adjacency list specified redundant – since network undirected, link node \\(\\) \\(j\\) necessarily entails link \\(j\\) back \\(\\). Setting above_diagonal=FALSE signalled adjacencylist_network() explicitly list redundant links. network can define succintly explicitly listing links node \\(\\) \\(j\\) \\(\\leq j\\), leaving adjacencylist_network() add reverse links, linke : confirm implicitly defined links indeed added, check neighbours node 4 see networks list nodes 1, 2, 3 6 expected neighbours node 4. can also query full adjacency lists networks network_adjacencylist() Note network_adjacencylist() default also omit redundant links case undirected networks, .e. skips links node \\(\\) \\(j\\) \\(> j\\). include neighbours nodes, set above_diagonal=FALSE. network_adjacencylist() works networks, matter originally defined. can thus use function query adjacency list synthetic networks, example Erdős–Rényi network makes possible modify synthetic networks. example, can merge Erdős–Rényi Barabási–Albert network resulting degree distribution neither Erdős–Rényi network (blue) Barabási–Albert (green)","code":"nw <- adjacencylist_network(list(   c(2, 3, 4, 5), # neighbours of node 1   c(1, 3, 4, 5), # neighbours of node 2   c(1, 2, 4, 6), # neighbours of node 3   c(1, 2, 3, 6), # neighbours of node 4   c(1, 2),       # neighbours of node 5   c(3, 4)        # neighbours of node 6 ), is_undirected=TRUE, above_diagonal=FALSE) nw2 <- adjacencylist_network(list(   c(2, 3, 4, 5),    c(3, 4, 5),   c(4, 6),   c(6),    c(),   c()      ), is_undirected=TRUE) print(network_neighbour(nw, 4, 1:network_outdegree(nw, 4))) #> [1] 1 2 3 6 print(network_neighbour(nw2, 4, 1:network_outdegree(nw2, 4))) #> [1] 1 2 3 6 print(network_adjacencylist(nw)) #> [[1]] #> [1] 2 3 4 5 #>  #> [[2]] #> [1] 3 4 5 #>  #> [[3]] #> [1] 4 6 #>  #> [[4]] #> [1] 6 #>  #> [[5]] #> integer(0) #>  #> [[6]] #> integer(0) print(network_adjacencylist(erdos_renyi_network(5, 2.5), above_diagonal=FALSE)) #> [[1]] #> [1] 2 3 5 #>  #> [[2]] #> [1] 1 4 5 #>  #> [[3]] #> [1] 1 4 #>  #> [[4]] #> [1] 2 3 #>  #> [[5]] #> [1] 1 2 N <- 100 k <- 10 m <- 5 al_er <- network_adjacencylist(erdos_renyi_network(N, k)) al_ba <- network_adjacencylist(barabasialbert_network(N, m)) al_merged <- mapply(FUN=function(x, y) unique(c(x,y)), al_er, al_ba) nw_merged <- adjacencylist_network(al_merged) ggplot(data.frame(degree=network_outdegree(nw_merged, 1:N))) +   geom_histogram(aes(x=degree, y=after_stat(count)),                  binwidth=5, fill='darkgrey', color=NA) +   geom_function(fun=function(n) 5 * N * dpois(round(n), k),                 n=1000, color='blue', linetype=\"dashed\", linewidth=0.5) +   geom_function(fun=function(n) 5 * N * 2*m*(m+1)/(n*(n+1)*(n+2)),                 n=1000, color='green', linetype=\"dashed\", linewidth=0.5)"},{"path":"https://oist.github.io/NEXTNetR/articles/empirical_networks.html","id":"weighted-networks","dir":"Articles","previous_headings":"Defining networks","what":"Weighted networks","title":"Empirical Networks","text":"define weighted network, adjacency list must contain list weights every list neighbours. Instead list vectors, therefore now pass list lists adjacencylist_weightednetwork(), contain two vectors names n neighbours w weights. can now query neighbours node 4, also weights corresponding links query adjacencylist weighted networks (matter created), can use weighted_network_adjacencylist()","code":"wnw <- adjacencylist_weightednetwork(list(   list(n=c(2, 3, 4, 5), w=c(1.5, 2,  2.5, 3)),    list(n=c(3, 4, 5),    w=c(2.5, 3,  3.5)),   list(n=c(4, 6),       w=c(3.5, 4.5)),   list(n=c(6),          w=c(5)),    list(n=c(), w=c()),   list(n=c(), w=c())      ), is_undirected=TRUE) print(network_neighbour_weight(wnw, 4, 1:network_outdegree(wnw, 4))) #> $n #> [1] 1 2 3 6 #>  #> $w #> [1] 2.5 3.0 3.5 5.0 print(weighted_network_adjacencylist(wnw)) #> [[1]] #> [[1]]$n #> [1] 2 3 4 5 #>  #> [[1]]$w #> [1] 1.5 2.0 2.5 3.0 #>  #>  #> [[2]] #> [[2]]$n #> [1] 3 4 5 #>  #> [[2]]$w #> [1] 2.5 3.0 3.5 #>  #>  #> [[3]] #> [[3]]$n #> [1] 4 6 #>  #> [[3]]$w #> [1] 3.5 4.5 #>  #>  #> [[4]] #> [[4]]$n #> [1] 6 #>  #> [[4]]$w #> [1] 5 #>  #>  #> [[5]] #> [[5]]$n #> integer(0) #>  #> [[5]]$w #> numeric(0) #>  #>  #> [[6]] #> [[6]]$n #> integer(0) #>  #> [[6]]$w #> numeric(0)"},{"path":"https://oist.github.io/NEXTNetR/articles/empirical_networks.html","id":"loading-networks-from-files","dir":"Articles","previous_headings":"Defining networks","what":"Loading networks from files","title":"Empirical Networks","text":"functions empirical_network() empirical_weightednetwork() allow networks read files. unweighted networks, file following format read yields network nw nw2 defined . separator whitespace default can changed something else, see help(empirical_network). gzip installed, gzip-compressed files extension .gz supported piped gzip read . Weighted networks supported empirical_weightednetwork, format read file, defines weighted network wnw , , gzip-compressed files supported gzip installed, separators neighbour-weight pairs neighbours weights can specified, see help(empirical_weightednetwork). Note example , link \\((4,6)\\) now weight \\(5\\) since weights two occurrences link summed","code":"# network.nw # Files may contains comment lines beginning with '#', # and an optional header line beginning with non-numeric text node neighbours .... # After the optional header, each line starts with a node and lists its # neighbours, separated by whitespace. The following line thus adds # links 1 -> 2, 1 -> 3, 1 -> 4, 1-> 5. For undirected networks, # the reversed edges are added as well. 1 2 3 4 5 # The neighbours of a single node can be split over multiple, possibly # non-consecutive lines. Here, we add 2 -> 4 and 2 -> 3, 2 -> 5. 2 4 2 3 5 3 4 5 4 6 # Nodes may be skipped, the largest node index defines the network size 6 nw3 <- empirical_network(path=\"network.nw\") # weighted_network.nw # Comment and header work like for unweighted networks # Weightes are specified after each neighbour, separated by a colon (:) 1 2:1.5 3:2 4:2.5 5:3 2 3:2.5 4:3 5:3.5 3 4:3.5 6:4.5 # Weights are summed over all occurences of a specific link 4 6:3 6 4:2 6 wnw3 <- empirical_weightednetwork(path=\"weighted_network.nw\") network_neighbour_weight(wnw3, 4, 4) #> $n #> [1] 1 #>  #> $w #> [1] 2.5"},{"path":"https://oist.github.io/NEXTNetR/articles/empirical_networks.html","id":"packaged-empirical-networks","dir":"Articles","previous_headings":"","what":"Packaged empirical networks","title":"Empirical Networks","text":"empirical_network() can download packaged networks directly NEXTNet-EmpiricalNetworks repository, contains selection empirical networks SNAP (Leskovec Krevl, 2014), ICON (Clauset et al., 2016) KONECT (Kunegis, 2013) databases. can download import “gowalla” network found SNAP database plot degree distribution double-logarithmic plot","code":"gowalla_nw <- empirical_network(name='gowalla') #> Downloading gowalla.gz to ~/.cache/NEXTNetR-EmpiricalNetworks/undirected ggplot(data.frame(degree=network_outdegree(gowalla_nw, 1:network_size(gowalla_nw)))) +   geom_density(aes(x=degree, y=after_stat(count)), bw=0.15) +   scale_x_log10() +   scale_y_log10()"},{"path":"https://oist.github.io/NEXTNetR/articles/spatial_temporal_networks.html","id":"loading-the-nextnetr-package","dir":"Articles","previous_headings":"","what":"Loading the NEXTNetR package","title":"Spatial and Temporal Networks","text":"start loading NEXTNetR package. package already installed, see website installation instructions. also load ggplot2 ggpubr packages plotting set nice theme.","code":"library(NEXTNetR) library(ggplot2) library(ggpubr) theme_set(theme_pubr())"},{"path":"https://oist.github.io/NEXTNetR/articles/spatial_temporal_networks.html","id":"spatial-networks","dir":"Articles","previous_headings":"","what":"Spatial Networks","title":"Spatial and Temporal Networks","text":"Next create spatially embedded network representing cubic lattice size \\(50\\times 50\\), .e. network nodes positioned integral coordinates \\((,j)\\) connected left, right, upper lower neighbour. spatially embedded networks lattices, can query positions nodes using network_coordinates().network_coordinates() returns \\(N \\times d\\) matrix, \\(N\\) number nodes \\(d\\) dimension embedding space, case 2. convenience, assign names coordinates, ‘x’ ‘y’. coordinate matrix looks like Using network_neighbour coordinate matrix just produced, can create matrix representing links nodes: row links represents link shows coordinate two involved nodes: two matrices coords links make easy plot network ggplot2.","code":"L <- 50 nw <- cubiclattice2d_network(L); N <- network_size(nw) coords <- network_coordinates(nw, 1:N) colnames(coords) <- c('x', 'y') head(coords) #>        x   y #> [1,] -24 -24 #> [2,] -23 -24 #> [3,] -22 -24 #> [4,] -21 -24 #> [5,] -20 -24 #> [6,] -19 -24 nodes_degrees <- network_outdegree(nw, 1:N) links_nodes <- rep(1:N, times=nodes_degrees) links_indices <- unlist(mapply(seq, from=1, to=nodes_degrees)) links <- cbind(links_nodes, network_neighbour(nw, links_nodes, links_indices)) head(links) #>      links_nodes    #> [1,]           1  2 #> [2,]           1 51 #> [3,]           2  3 #> [4,]           2  1 #> [5,]           2 52 #> [6,]           3  4 ggplot() +   geom_point(data=coords, aes(x=x, y=y),              size=0.5) +   geom_segment(data=cbind(a=as.data.frame(coords[links[, 1],]),                           b=as.data.frame(coords[links[, 2],])),                aes(x=a.x, y=a.y, xend=b.x, yend=b.y),                linewidth=0.1) +   theme_void()"},{"path":"https://oist.github.io/NEXTNetR/articles/spatial_temporal_networks.html","id":"a-plot_network-function","dir":"Articles","previous_headings":"Spatial Networks","what":"A plot_network function","title":"Spatial and Temporal Networks","text":"simulate epidemic, create convenience function plot_network visualize state epidemic. function uses simulation_isinfected() query infected state node show non-infected infected nodes different colors. make sure plot encompasses whole network, use network_bounds() query bounds network space set plotting limits","code":"plot_network <- function(nw, sim=NULL) {   # Node coordinates   N <- network_size(nw)   coords <- network_coordinates(nw, 1:N)   colnames(coords) <- c('x', 'y')      # Link coordinates   nodes_degrees <- network_outdegree(nw, 1:N)   links_nodes <- rep(1:N, times=nodes_degrees)   links_indices <- unlist(mapply(seq, from=1, to=nodes_degrees))   links <- cbind(links_nodes, network_neighbour(nw, links_nodes, links_indices))      # Boundaries   bounds <- network_bounds(nw)      # Get data   infected <- if (!is.null(sim))     as.factor(simulation_isinfected(sim, 1:N))   else     as.factor(rep(FALSE, N))   data_nodes <- cbind(as.data.frame(coords),                       infected=infected)   data_links <- cbind(a=as.data.frame(coords[links[, 1],]),                       b=as.data.frame(coords[links[, 2],]))      # Plot network   ggplot() +     geom_point(data=data_nodes, aes(x=x, y=y, color=infected, size=infected)) +     geom_segment(data=data_links, aes(x=a.x, y=a.y, xend=b.x, yend=b.y),                  linewidth=0.1) +     scale_color_manual(breaks=c(FALSE,TRUE), values=c('cornflowerblue','orange')) +     scale_size_manual(breaks=c(FALSE,TRUE), values=c(0.5, 2.0)) +     labs(color=\"infected\", size=\"infected\") +     lims(x=c(bounds[[1]][1], bounds[[2]][1]),          y=c(bounds[[1]][2], bounds[[2]][2])) +     theme_void() +     theme(legend.position = 'none') }"},{"path":"https://oist.github.io/NEXTNetR/articles/spatial_temporal_networks.html","id":"epidemics-on-spatial-netwoks","dir":"Articles","previous_headings":"Spatial Networks","what":"Epidemics on spatial netwoks","title":"Spatial and Temporal Networks","text":"now create animation depicting spread epidemic lattice, starting single initial infection center lattice. iteration loop, simulation run stopping time t1 current epidemic state plotted. full list events available later , combine events reported calls simulation_run merge large table end.  Finally, plot number infected nodes function time. log-plot, see epidemic show clear exponential regime  instead plot trajectory log-log plot clearly see effect rather dense 2-dimensional embedding nodes – instead growing exponentially, epidemic grows quadratically.","code":"infection_time <- gamma_time(mean=6, var=4) sim <- simulation(nw=nw, psi=infection_time) simulation_addinfections(sim, nodes=L*floor(L/2) - L/2, times=c(0.0))  events <- list() i <- 0 for(t1 in seq(from=0, to=250, by=5)) {   i <- i + 1   events[[i]] <- simulation_run(sim, stop=list(time=t1))   print(plot_network(nw, sim)) } events <- do.call(rbind, events) ggplot(events) +   geom_line(aes(x=time, y=infected)) +   scale_y_log10() ggplot(events) +   geom_line(aes(x=time, y=infected)) +   scale_x_log10() +   scale_y_log10() +   geom_abline(slope=2, intercept=-1, linetype='dashed', color='blue')"},{"path":"https://oist.github.io/NEXTNetR/articles/spatial_temporal_networks.html","id":"temporal-networks","dir":"Articles","previous_headings":"","what":"Temporal networks","title":"Spatial and Temporal Networks","text":"Instead static network defined cubiclattice2d_network(), now consider temporal network. temporal networks, set links nodes function time, .e. links appear disappear, see help(network_types). example temporal network brownian_proximity_temporalnetwork() nodes diffuse randomly two dimensions instant connected nodes within certain radius. density points chosen instant time, node average prescribed number neighbours avg_degree. Speed movement governed two diffusion constants D0 susceptible nodes D1 infected nodes describe average squared distance per unit time node moves. resulting network initially looks like  Since network random, node indices correspond position nodes plane. However, can use network_coordinates find node closest center plane.","code":"N2 <- 2500 nw2 <- brownian_proximity_temporalnetwork(   N2, avg_degree=4, D0=1.0, D1=1.0, radius=1, dt=0.05) plot_network(nw2) bounds2 <- network_bounds(nw2) center2 <- 0.5*bounds2[[1]] + 0.5*bounds2[[2]] coords2 <- network_coordinates(nw2, 1:N2) d2 <- apply(coords2, MARGIN=1, function(x) sum((x - center2)**2)) CENTERNODE2 <- which.min(d2)"},{"path":"https://oist.github.io/NEXTNetR/articles/spatial_temporal_networks.html","id":"epidemics-on-temporal-networks","dir":"Articles","previous_headings":"Temporal networks","what":"Epidemics on temporal networks","title":"Spatial and Temporal Networks","text":"Epidemics temporal networks way static networks, creating simulator object simulation() calling simulation_run(). However, simulation_run() change epidemic state nodes, also evolve network. Contrary situation static network, temporal networks thus modified simulation_run() called. now proceed lattice create animation depicting spread epidemic Brownian proximity network","code":"infection_time2 <- gamma_time(mean=6, var=4) sim2 <- simulation(nw=nw2, psi=infection_time2) simulation_addinfections(sim2, nodes=CENTERNODE2, times=c(0.0))  events2 <- list() i <- 0 for(t1 in seq(from=0, to=60, by=0.2)) {   i <- i + 1   events2[[i]] <- simulation_run(sim2, stop=list(time=t1, infected=N2))   print(plot_network(nw2, sim2)) } events2 <- do.call(rbind, events2)"},{"path":"https://oist.github.io/NEXTNetR/articles/spatial_temporal_networks.html","id":"the-effect-of-diffusion-on-epidemic-growth","dir":"Articles","previous_headings":"Temporal networks","what":"The effect of diffusion on epidemic growth","title":"Spatial and Temporal Networks","text":"log-plot number infected node shows contrary case lattice, number infected nodes initially grows exponentially Brownian proximity network, despite fact average degree nodes 4 networks.","code":"ggplot(events2) +   geom_line(aes(x=time, y=infected, color='Brownian proximity')) +   geom_line(data=events, aes(x=time, y=infected, color='lattice')) +   scale_y_log10() +   lims(x=range(events2$time))"},{"path":"https://oist.github.io/NEXTNetR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Florian Pflug. Author, maintainer. Samuel Cure. Author.","code":""},{"path":"https://oist.github.io/NEXTNetR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Cure S, Pflug FG, Pigolotti S (2024). “Fast exact simulations stochastic epidemics static temporal networks.” arXiv, 2412.07095. doi:10.48550/arXiv.2412.07095.","code":"@Article{,   title = {Fast and exact simulations of stochastic epidemics on static and temporal networks},   author = {Samuel Cure and Florian G. Pflug and Simone Pigolotti},   year = {2024},   journal = {arXiv},   pages = {2412.07095},   doi = {https://doi.org/10.48550/arXiv.2412.07095}, }"},{"path":"https://oist.github.io/NEXTNetR/index.html","id":"introduction","dir":"","previous_headings":"","what":"Efficient simulation of epidemics on complex networks using the NEXTNet library","title":"Efficient simulation of epidemics on complex networks using the NEXTNet library","text":"NEXTNetR (Next-reaction-based Epidemics eXtended Temporal Networks) R package efficient simulation epidemics complex networks (including weighted temporal networks) arbitrary transmission recovery time distributions. NEXTNetR R wrapper around C++ library NEXTNet. prefer user Python, NEXTNetPy offers similar wrapper Python.","code":""},{"path":"https://oist.github.io/NEXTNetR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Efficient simulation of epidemics on complex networks using the NEXTNet library","text":"Git available, latest released version NEXTNetR can installed directly Github executing following R: Alternatively, download latest released version NEXTNetR-v<version>-pkg.tar.gz. make sure required dependencies installed install.packages(c(\"BH\", \"cpp11\", \"rappdirs\")) install NEXTNetR command line (within R) Since NEXT-Net implemented C++, C++ compiler required install NEXTNetR. Linux compiler typically already available, Mac OS R suitable compiler provided XCode XCode Command Line Tools, Windows RTools.","code":"install.packages(\"remotes\") remotes::install_github(\"oist/NEXTNetR\", ref=\"latest-release\") R CMD INSTALL NEXTNetR-v<version>-pkg.tar.gz"},{"path":"https://oist.github.io/NEXTNetR/index.html","id":"synopsis","dir":"","previous_headings":"","what":"Synopsis","title":"Efficient simulation of epidemics on complex networks using the NEXTNet library","text":"following minimal example simulated epidemic Erdős–Rényi network lognormally distributed transmission time See Getting Started stey--step instructions use NEXTNetR.","code":"library(NEXTNetR) sim <- simulation(     erdos_renyi_network(1e5, 5),     lognormal_time(6, 30, 0.1)) simulation_addinfections(sim, 1, 0.0) r <- simulation_run(sim, stop=list(total_infected=300e3)) plot(r$time, r$infected, type='l')"},{"path":"https://oist.github.io/NEXTNetR/index.html","id":"supported-features","dir":"","previous_headings":"","what":"Supported Features","title":"Efficient simulation of epidemics on complex networks using the NEXTNet library","text":"NEXTNetR offers range common types artifical networks erdos_renyi(), see help(network_types) full list. adjacencylist_network() adjacencylist_weightednetwork() allow arbitrary unweighted weighted networks used simulations. Transmission recovery times can likewise arbitrary probability distributions, see help(time_distributions). NEXTNetR also allows simulations temporal networks, .e. networks change time, possibly response epidemic events. Amongst temporal networks currently supported NEXTNetR empirical_contact_temporalnetwork() activity_driven_temporalnetwork(), see help(network_types) full list.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/activity_driven_temporalnetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Activity-driven network model of Cai, Nie & Holme (2024). — activity_driven_temporalnetwork","title":"Activity-driven network model of Cai, Nie & Holme (2024). — activity_driven_temporalnetwork","text":", nodes initially inactive degree zero. Node \\(\\) activates rate \\([] * \\eta\\) upon activation connects \\(m\\) uniformly chosen nodes (necessarily active). Active nodes inactivate constant rate \\(b\\). See Cai, Nie & Holme 2024, Phys. Rev. Research 6, L022017 details. , implement generalized version model activation deacivation rates infected nodes can differ non-infected node.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/activity_driven_temporalnetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Activity-driven network model of Cai, Nie & Holme (2024). — activity_driven_temporalnetwork","text":"","code":"activity_driven_temporalnetwork(   activities,   m,   eta,   b,   eta_inf = eta,   b_inf = b )"},{"path":"https://oist.github.io/NEXTNetR/reference/activity_driven_temporalnetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Activity-driven network model of Cai, Nie & Holme (2024). — activity_driven_temporalnetwork","text":"activities node-specific activities \\(a_1,a_2,\\ldots\\) m number nodes activated node connects eta activation rate b deactivation rate eta_inf activation rate infected nodes b_inf deactivation rate infected nodes","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/acyclic_network.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an acyclic network — acyclic_network","title":"Create an acyclic network — acyclic_network","text":"Creates acyclic network given size average degree. Node degrees follow Possonian distribution.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/acyclic_network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an acyclic network — acyclic_network","text":"","code":"acyclic_network(size, avg_degree, reduced_root_degree)"},{"path":"https://oist.github.io/NEXTNetR/reference/acyclic_network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an acyclic network — acyclic_network","text":"size number nodes avg_degree average number neighbour node reduced_root_degree true, degree root node reduced one","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/acyclic_network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an acyclic network — acyclic_network","text":"network object","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/adjacencylist_network.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a network from an adjacency list — adjacencylist_network","title":"Create a network from an adjacency list — adjacencylist_network","text":"Create network object adjacencylist","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/adjacencylist_network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a network from an adjacency list — adjacencylist_network","text":"","code":"adjacencylist_network(   adjacencylist,   is_undirected = TRUE,   above_diagonal = is_undirected )"},{"path":"https://oist.github.io/NEXTNetR/reference/adjacencylist_network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a network from an adjacency list — adjacencylist_network","text":"adjacencylist list vectors containing neighbours node. format return value network_adjacencylist. is_undirected TRUE network supposed undirected, .e. contains link \\(\\) \\(j\\) exactly contains link \\(j\\) \\(\\). above_diagonal set TRUE network undirected adjacencylist contains edges \\(,j\\) \\(\\leq j\\), .e. represent upper triangular submatrix adjacency matrix. Defaults TRUE undirected networks.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/adjacencylist_network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a network from an adjacency list — adjacencylist_network","text":"network object","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/adjacencylist_weightednetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a network from an adjacency list — adjacencylist_weightednetwork","title":"Create a network from an adjacency list — adjacencylist_weightednetwork","text":"Create network object adjacency list","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/adjacencylist_weightednetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a network from an adjacency list — adjacencylist_weightednetwork","text":"","code":"adjacencylist_weightednetwork(   adjacencylist,   is_undirected = FALSE,   above_diagonal = is_undirected )"},{"path":"https://oist.github.io/NEXTNetR/reference/adjacencylist_weightednetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a network from an adjacency list — adjacencylist_weightednetwork","text":"adjacencylist list vectors containing neighbours node. format return value weighted_network_adjacencylist. is_undirected TRUE network supposed undirected, .e. contains link \\(\\) \\(j\\) exactly contains link \\(j\\) \\(\\). above_diagonal set TRUE network undirected adjacencylist contains edges \\(,j\\) \\(\\leq j\\), .e. represent upper triangular submatrix adjacency matrix. Defaults TRUE undirected networks.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/adjacencylist_weightednetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a network from an adjacency list — adjacencylist_weightednetwork","text":"network object","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/barabasialbert_network.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an Barabasi-Albert network — barabasialbert_network","title":"Create an Barabasi-Albert network — barabasialbert_network","text":"Create Barabasi-Albert prefential attachment network given size parameter \\(m\\)","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/barabasialbert_network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an Barabasi-Albert network — barabasialbert_network","text":"","code":"barabasialbert_network(size, m)"},{"path":"https://oist.github.io/NEXTNetR/reference/barabasialbert_network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an Barabasi-Albert network — barabasialbert_network","text":"size number nodes network m number nodes new node attaches ","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/barabasialbert_network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an Barabasi-Albert network — barabasialbert_network","text":"network object","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/brownian_proximity_temporalnetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Brownian proximity network — brownian_proximity_temporalnetwork","title":"Create a Brownian proximity network — brownian_proximity_temporalnetwork","text":"Create Brownian proximity network. size nodes places randomly two dimensions, connected links distance exceed radius. size playing field chosen expected number neighbours node avg_degree. resulting network temporal, .e. evolves time. Non-infected nodes diffuse diffusivity \\(D_0\\), infected nodes diffusivity \\(D_1\\). number infected nodes grows, diffusivities additionally scaled factor \\((1 - N_{inf} / N)^{\\gamma}\\). network evolves descreet time steps length dt. left unspecified, suitable dt chosen automatically based diffusivities contact radius.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/brownian_proximity_temporalnetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Brownian proximity network — brownian_proximity_temporalnetwork","text":"","code":"brownian_proximity_temporalnetwork(   size,   avg_degree,   radius,   D0,   D1 = NULL,   gamma = 0,   dt = NULL )"},{"path":"https://oist.github.io/NEXTNetR/reference/brownian_proximity_temporalnetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Brownian proximity network — brownian_proximity_temporalnetwork","text":"size number nodes network avg_degree average number neighbours node radius contact radius, .e. distance two nodes connected links D0 diffusivity non-infected nodes D1 diffusivity infected nodes gamma exponenent diffusivities scaled epidemic grows dt time step used evolving network","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/brownian_proximity_temporalnetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Brownian proximity network — brownian_proximity_temporalnetwork","text":"network object","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/configmodel_clustered_network.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an network with the specified node degrees and clustering — configmodel_clustered_network","title":"Create an network with the specified node degrees and clustering — configmodel_clustered_network","text":"Creates network nodes degrees specified numbers triangles specified using implementation algorithm Serrano & Boguñá, 2005, Phys. Rev. E 72, 036133.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/configmodel_clustered_network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an network with the specified node degrees and clustering — configmodel_clustered_network","text":"","code":"configmodel_clustered_network(   degrees,   beta,   alpha = NULL,   ck = NULL,   triangles = NULL )"},{"path":"https://oist.github.io/NEXTNetR/reference/configmodel_clustered_network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an network with the specified node degrees and clustering — configmodel_clustered_network","text":"degrees vector length \\(N\\) listing degrees nodes beta parameter defines degree class probabilities \\(P(k)\\) alpha set \\(c(k)=0.5*(k-1)^\\alpha\\) ck arbitrary function \\(c(k)\\) probability \\(b\\), \\(c\\) neighbours \\(\\), \\(b\\) \\(c\\) neighbours. triangles number triangles overlapping nodes degree 0, 1, 2, ...,","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/configmodel_clustered_network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an network with the specified node degrees and clustering — configmodel_clustered_network","text":"network object","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/configmodel_network.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an network with the specified node degrees — configmodel_network","title":"Create an network with the specified node degrees — configmodel_network","text":"Creates network nodes degrees specified","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/configmodel_network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an network with the specified node degrees — configmodel_network","text":"","code":"configmodel_network(degrees)"},{"path":"https://oist.github.io/NEXTNetR/reference/configmodel_network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an network with the specified node degrees — configmodel_network","text":"degrees vector length \\(N\\) listing degrees nodes","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/configmodel_network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an network with the specified node degrees — configmodel_network","text":"network object","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/cubiclattice_network.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an cubic lattice — cubiclattice_network","title":"Create an cubic lattice — cubiclattice_network","text":"Creates cubic lattice specified number dimensions","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/cubiclattice_network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an cubic lattice — cubiclattice_network","text":"","code":"cubiclattice2d_network(length)  cubiclattice3d_network(length)  cubiclattice4d_network(length)  cubiclattice5d_network(length)  cubiclattice6d_network(length)  cubiclattice7d_network(length)  cubiclattice8d_network(length)"},{"path":"https://oist.github.io/NEXTNetR/reference/cubiclattice_network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an cubic lattice — cubiclattice_network","text":"length number nodes side \\(d\\)-dimensional cube","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/cubiclattice_network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an cubic lattice — cubiclattice_network","text":"network object","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/empirical_contact_temporalnetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirical temporal network comprising short contacts between nodes — empirical_contact_temporalnetwork","title":"Empirical temporal network comprising short contacts between nodes — empirical_contact_temporalnetwork","text":"Can read networks file, download networks packages NEXT-Net directly NEXTNet-EmpiricalNetworks repository. line file must list single contact form \"\"   integers specifying nodes  floating-point value. highest node index appearing within   defines size network. Finite-duration contacts extend dt/2 around time specified file.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/empirical_contact_temporalnetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirical temporal network comprising short contacts between nodes — empirical_contact_temporalnetwork","text":"","code":"empirical_contact_temporalnetwork(   path,   dt,   weight,   finite_duration = FALSE,   name = NULL,   group = \"contact\",   gzip = grepl(\"\\\\.gz$\", path),   download.timeout = 300 )"},{"path":"https://oist.github.io/NEXTNetR/reference/empirical_contact_temporalnetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Empirical temporal network comprising short contacts between nodes — empirical_contact_temporalnetwork","text":"path name file dt duration contacts weight weight contacts, instantaneous contacts effective weight weight * dt. finite_duration whether treat contacts finite duration dt instantaneous effective weight weight * dt name name packaged empirical network, see packaged_empirical_network group packaged empirical network group containing network gzip whether file compressed download.timeout packaged networks download timeout","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/empirical_network.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a network for an adjacency list stored in a file — empirical_network","title":"Creates a network for an adjacency list stored in a file — empirical_network","text":"Can read networks file, download networks packages NEXT-Net directly NEXTNet-EmpiricalNetworks repository. file must contain one line per node listing first node node's neighbours, separated whitespace (default; separated can specified). Node identified numbers starting idxbase (default 1); maximal node index appears file defines size network. undirected networks (.e. undirected=TRUE), every link (u,v) listed file reverse link (v,u) added well. Lines starting comment chracter '#' skipped. first non-comment line start numerical node index, assumed header line skipped well.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/empirical_network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a network for an adjacency list stored in a file — empirical_network","text":"","code":"empirical_network(   path,   name = NULL,   group = \"undirected\",   undirected = TRUE,   simplify = FALSE,   idxbase = 1,   sep = \" \",   gzip = grepl(\"\\\\.gz$\", path),   download.timeout = 300 )"},{"path":"https://oist.github.io/NEXTNetR/reference/empirical_network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a network for an adjacency list stored in a file — empirical_network","text":"path name file name name packaged empirical network, see packaged_empirical_network group packaged empirical network group containing network undirected TRUE network assumed undirected simplify whether remove self-edges multi-edges idxbase index first node (typically 1 0, default 1) sep separator, default whitespace gzip whether file compressed download.timeout packaged networks download timeout","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/empirical_network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a network for an adjacency list stored in a file — empirical_network","text":"network object","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/empirical_weightednetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a weighted network for an adjacency list stored in a file — empirical_weightednetwork","title":"Creates a weighted network for an adjacency list stored in a file — empirical_weightednetwork","text":"file must contain one line per node listing first node pairs neighbours weights. Pairs separated whitespace, neighbours weights colon (':'); separators can specifed. Nodes identified numbers starting idxbase (default 1); maximal node index appears file defines size network. undirected networks (.e. undirected=TRUE), every link (u,v) listed file reverse link (v,u) added well. Lines starting comment chracter '#' skipped. first non-comment line start numerical node index, assumed header line skipped well.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/empirical_weightednetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a weighted network for an adjacency list stored in a file — empirical_weightednetwork","text":"","code":"empirical_weightednetwork(   path,   undirected = TRUE,   simplify = FALSE,   idxbase = 1,   csep = \" \",   wsep = \":\",   gzip = grepl(\"\\\\.gz$\", path) )"},{"path":"https://oist.github.io/NEXTNetR/reference/empirical_weightednetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a weighted network for an adjacency list stored in a file — empirical_weightednetwork","text":"path name file undirected TRUE network assumed undirected simplify whether remove self-edges multi-edges idxbase index first node (typically 1 0, default 1) csep separator neighbours/weight pairs, default whitespace wsep separator neighbour weight, default ':' gzip whether file compressed","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/empirical_weightednetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a weighted network for an adjacency list stored in a file — empirical_weightednetwork","text":"network object","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/erdos_renyi_network.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Erdös-Rényi network — erdos_renyi_network","title":"Create a Erdös-Rényi network — erdos_renyi_network","text":"Creates Erdös-Rényi network given size average degree","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/erdos_renyi_network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Erdös-Rényi network — erdos_renyi_network","text":"","code":"erdos_renyi_network(size, avg_degree)  erdos_reyni_network(size, avg_degree)"},{"path":"https://oist.github.io/NEXTNetR/reference/erdos_renyi_network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Erdös-Rényi network — erdos_renyi_network","text":"size number nodes avg_degree average number neighbour node ","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/erdos_renyi_network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Erdös-Rényi network — erdos_renyi_network","text":"network object","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/erdos_renyi_network.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Erdös-Rényi network — erdos_renyi_network","text":"name function previously miss-spelled erdos_reyni_network, still available also old name.","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/erdos_renyi_temporalnetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a temporal Erdös-Rényi network — erdos_renyi_temporalnetwork","title":"Create a temporal Erdös-Rényi network — erdos_renyi_temporalnetwork","text":"Creates temporal Erdös-Rényi network given size average degree.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/erdos_renyi_temporalnetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a temporal Erdös-Rényi network — erdos_renyi_temporalnetwork","text":"","code":"erdos_renyi_temporalnetwork(size, avg_degree, timescale)"},{"path":"https://oist.github.io/NEXTNetR/reference/erdos_renyi_temporalnetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a temporal Erdös-Rényi network — erdos_renyi_temporalnetwork","text":"size number nodes (\\(n\\)) avg_degree average number neighbour node (\\(k\\)) timescale time scale network evolution (\\(\\tau\\))","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/erdos_renyi_temporalnetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a temporal Erdös-Rényi network — erdos_renyi_temporalnetwork","text":"network object","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/erdos_renyi_temporalnetwork.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a temporal Erdös-Rényi network — erdos_renyi_temporalnetwork","text":"point time, temporal Erdös-Rényi network resembles static Erdös-Rényi network possible edge exists network uniform probability \\(p_+ = k / (n - 1)\\) \\(k\\) average node degree \\(n\\) number nodes. state edge possible evolves independently time, appearing rate \\(\\lambda_+ = p_+ / \\tau\\) disappearing rate \\(\\lambda_- = p_- / \\tau\\) \\(\\tau\\) time scale.","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/erdos_renyi_weightednetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a weighted Erdös-Rényi network — erdos_renyi_weightednetwork","title":"Create a weighted Erdös-Rényi network — erdos_renyi_weightednetwork","text":"Creates weighted Erdös-Rényi network given size average degree ..d. edge weights. weight distribution specified vector weights vector corresponding probabilities.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/erdos_renyi_weightednetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a weighted Erdös-Rényi network — erdos_renyi_weightednetwork","text":"","code":"erdos_renyi_weightednetwork(size, avg_degree, weights, probabilities)"},{"path":"https://oist.github.io/NEXTNetR/reference/erdos_renyi_weightednetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a weighted Erdös-Rényi network — erdos_renyi_weightednetwork","text":"size number nodes avg_degree average number neighbour node weights edge weights probabilities edge weight probabilities, must length weights","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/erdos_renyi_weightednetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a weighted Erdös-Rényi network — erdos_renyi_weightednetwork","text":"network object","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/fully_connected_network.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a fully-connected network — fully_connected_network","title":"Create a fully-connected network — fully_connected_network","text":"Creates fully-connected network given size","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/fully_connected_network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a fully-connected network — fully_connected_network","text":"","code":"fully_connected_network(size)"},{"path":"https://oist.github.io/NEXTNetR/reference/fully_connected_network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a fully-connected network — fully_connected_network","text":"size number nodes","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/fully_connected_network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a fully-connected network — fully_connected_network","text":"network object","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/network_properties.html","id":null,"dir":"Reference","previous_headings":"","what":"Querying properties of networks — network_properties","title":"Querying properties of networks — network_properties","text":"functions allow properties topology networks inspected","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/network_properties.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Querying properties of networks — network_properties","text":"","code":"network_is_undirected(nw)  network_is_simple(nw)  network_is_weighted(nw)  network_is_temporal(nw)  network_size(nw)  network_outdegree(nw, nodes)  network_neighbour(nw, nodes, indices)  network_neighbour_weight(nw, nodes, indices)  network_adjacencylist(nw, above_diagonal = network_is_undirected(nw))  weighted_network_adjacencylist(nw, above_diagonal = network_is_undirected(nw))  network_bounds(nw)  network_coordinates(nw, nodes)"},{"path":"https://oist.github.io/NEXTNetR/reference/network_properties.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Querying properties of networks — network_properties","text":"nw network object nodes vector node indices indices vector neighbour indices","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/network_properties.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Querying properties of networks — network_properties","text":"network_is_simple(nw) returns true network simple, .e. neither contains self-edges multi-edges. Note false imply network necessarily contains self- multi-edges, guaranteed simple construction. network_is_undirected(nw) returns true network directed, .e. link node \\(\\) \\(j\\) exactly link node \\(j\\) \\(\\). Note similar network_is_simple, return value true guarantees network undirected, false imply existence edge without reversed counterpart. network_is_weighted(nw) return true network weighted, .e. links associated weights network_is_temporal(nw) return true network temporal, .e. links can appear disappear epidemic simulations network_size(nw) returns number nodes network network_outdegree(nw, node) returns vector length nodes containing  -degrees (.e. number outgoing links) nodes nodes. network_neighbour(nw, nodes, indices) returns vector length nodes indices containing neighbours given index given nodes. network_neighbour_weight(nw, nodes, indices) returns named list containing vectors \"n\" \"w\". \"n\" vector length nodes indices contains neighbours given index given nodes. \"w\" vector length contains corresponding weights. network_adjacencylist(nw, above_diagonal=network_is_undirected(nw)) returns list interger vectors \\(\\)-th vector contains neighbours node \\(\\). undirected networks, edge pair \\((,j)\\) \\((j, )\\) edge \\((,j)\\) \\(\\leq j\\) output, .e. upper triangular submatrix symmetric adjacency matrix considered. include edges, set above_diagonal=FALSE. weighted_network_adjacencylist(nw, above_diagonal=network_is_undirected(nw)) returns list named lists containing vectors \"n\" \"w\". vector \"n\" \\(\\)-th list contains neighbours node \\(\\), vector \"w\" contains corresponding weights. undirected networks, edge pair \\((,j)\\) \\((j, )\\) edge \\((,j)\\) \\(\\leq j\\) output, .e. upper triangular submatrix symmetric adjacency matrix considered. include edges, set above_diagonal=FALSE. network_bounds(nw) networks embedded \\(d\\)-dimensional space, function returns list containing two vectors length \\(d\\), \\(x\\) \\(y\\). \\(x\\) lower-bound \\(y\\) upper bound coordinates nodes network. network_coordinates(nw, nodes) networks embedded \\(d\\)-dimensional space, function returns \\(n\\times d\\) matrix containing coordinates \\(n\\) nodes listed nodes.","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/network_reproduction_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the reproduction matrix \\(M\\), reproduction number \\(R\\), and other statistics related to these quantites. — network_reproduction_matrix","title":"Computes the reproduction matrix \\(M\\), reproduction number \\(R\\), and other statistics related to these quantites. — network_reproduction_matrix","text":"Computes reproduction matrix \\(M\\), reproduction number \\(R\\), statistics related quantites.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/network_reproduction_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the reproduction matrix \\(M\\), reproduction number \\(R\\), and other statistics related to these quantites. — network_reproduction_matrix","text":"","code":"network_reproduction_matrix(nw)"},{"path":"https://oist.github.io/NEXTNetR/reference/network_reproduction_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes the reproduction matrix \\(M\\), reproduction number \\(R\\), and other statistics related to these quantites. — network_reproduction_matrix","text":"named list containing entries M, r, k1, k2, k3, m_bar, R0, R_r, R_pert. See Details description quantites","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/network_reproduction_matrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computes the reproduction matrix \\(M\\), reproduction number \\(R\\), and other statistics related to these quantites. — network_reproduction_matrix","text":"Computes following quantities M: Reproduction matrix, \\(M_{ij}\\) number susceptible individuals \\(\\)-th smallest degree connected node \\(j\\)-th smallest degree. r: Degree correlation (assortativity) k1: first raw moment degree distribution. k2: second raw moment degree distribution. k3: third raw moment degree distribution. m1: average number triangles link part . m2: second moment related \\(m_1\\). R0: basic reproduction number \\(R_0 = (k_2 - k_1) / k_1\\) R_r: reproduction number taking assortativity clustering accounts, like \\(R_{pert}\\) \\(m_1\\), \\(m_2\\) set zero. R_pert: reproduction number estimated \\(R_0\\), \\(r\\), \\(m_1\\), \\(m_2\\) \\(k_1\\), \\(k_2\\), \\(k_3\\). See Cure, Pflug & Pigolotti, Exponential rate epidemic spreading complex networks, Physical Review E, 111, 044311 detailed discussion quantities","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/network_types.html","id":null,"dir":"Reference","previous_headings":"","what":"Creating networks — network_types","title":"Creating networks — network_types","text":"NEXTNet, networks directed graphs, .e. fully defined set nodes \\(V\\) edges (links) \\(E \\subset V \\times V\\) self-edges .e. links form \\((v,v)\\) forbidden. NEXTNet provides various different types algorithms creating synthetic networks, well networks defined specifying \\(V\\) \\(E\\). addition plain (unweighted static) networks defined , NEXTNet also supports temporal weighted networks. temporal networks, set edges/links depends time \\(t\\), .e. \\(E=E(t)\\). networks, epidemics can spread node \\(u\\) node \\(v\\) times \\((u,v) \\E(t)\\). times, infectiousness \\(u\\) particular link \\((u,v)\\) effectively zero. weighted networks, \\(e \\E\\) assigned weight \\(w_e \\geq 0\\). weights modulate infectiousness nodes, see discussion time_distributions. Weighted networks can interpreted limit case temporal networks edges fluctuate high frequency. weight expresses fraction times link present. NEXTNetR supports following types static, unweighted networks: empirical_network: Network defined arbitrary adjacency list read file. adjacencylist_network Network defined arbitrary adjacency list. erdos_renyi_network: Erdős–Rényi network, .e. edges sampled ..d fully-connected network. fully_connected_network: Fully connected network, .e. possible edges exist. acyclic_network: Tree-shaped network. configmodel_network: Network specified number nodes certain degree. configmodel_clustered_network: Configuration model clustering. wattsstrogatz_network: barabasialbert_network: Barabási–Albert prefertial attachment network. cubiclattice_network: Cubic lattice 2 8 dimensions. following static weighted networks empirical_weightednetwork: Weighted network defined adjacency list read file adjacencylist_weightednetwork: Network defined arbitrary adjacency list weighted edges. erdos_renyi_weightednetwork: Erdős–Rényi network ..d edge weights. following temporal networks empirical_contact_temporalnetwork: Network defined contacts pre-defined times read file. erdos_renyi_temporalnetwork: Erdős–Rényi network temporally evolving edges. brownian_proximity_temporalnetwork: Proximity network Brownian particles two dimensions. sirx_temporalnetwork: Network version SIRX model proposed Maier & Brockmann, 2020","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/packaged_empirical_network.html","id":null,"dir":"Reference","previous_headings":"","what":"Downloads a packages empirical network and returns the file path — packaged_empirical_network","title":"Downloads a packages empirical network and returns the file path — packaged_empirical_network","text":"See NEXTNetR-EmpiricalNetworks list available networks.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/packaged_empirical_network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Downloads a packages empirical network and returns the file path — packaged_empirical_network","text":"","code":"packaged_empirical_network(   name,   group = \"undirected\",   format = \"gz\",   timeout = 300 )"},{"path":"https://oist.github.io/NEXTNetR/reference/packaged_empirical_network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Downloads a packages empirical network and returns the file path — packaged_empirical_network","text":"name name network format file format timeout timeout downloading type type network","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/packaged_empirical_network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Downloads a packages empirical network and returns the file path — packaged_empirical_network","text":"path downloaded file Downloaded files cached directory `rappdirs::user_cache_dir(appname=\"EmpiricalNetworks\", appauthor=\"NEXTNetR\"'","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/simulation.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a simulation — simulation","title":"Create a simulation — simulation","text":"Simulatiojn objects represent single simulation specific network using specific tranmission reset/recovery times. network can weighted /temporal, see network_types. force temporal network treated static network, set option static_network TRUE.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/simulation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a simulation — simulation","text":"","code":"simulation(nw, psi, rho = NULL, options = list(), method = \"nextreaction\")"},{"path":"https://oist.github.io/NEXTNetR/reference/simulation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a simulation — simulation","text":"nw network simulate psi infection time distribution options named list algorithm options, see method simulation method use, currently 'nextreaction' rhi reset/recovery time distribution","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/simulation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a simulation — simulation","text":"simulation object. See simulation_run run simulation simulation_functions functions operate simulations.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/simulation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a simulation — simulation","text":"Possible options SIR: make recovered nodes susceptible SIR model. Default FALSE. static_network: Treat network static, even temporal network. Default FALSE. shuffle_neighbours: Shuffle neighbours upon infecting node. Default TRUE. edges_concurrent: Activate outgoing edges simultaenously sequentially. set true, neighbours implicitly shuffled shuffle_neighbours thus effect. Default FALSE.","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/simulation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a simulation — simulation","text":"","code":"# Create contact network network nw <- erdos_renyi_network(1e5, 5) # Create transmission and reset time distributions psi <- lognormal_time(6, 30, 0.1) rho <- weibull_time(shape=5, scale=50) # Create simulation and specifiy initial set of infections sim <- simulation(nw, psi, rho) simulation_addinfections(sim, nodes=c(1), times=c(0.0)) # Run simulation until time t=100 or 200,000 infections have occured r <- simulation_run(sim, stop=list(time=300, total_infected=300e3)) # Plot the number of infected nodes against time plot(r$time, r$infected, type='l')"},{"path":"https://oist.github.io/NEXTNetR/reference/simulation_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Running simulations and querying their state and properties — simulation_functions","title":"Running simulations and querying their state and properties — simulation_functions","text":"functions allow simulations created simulation run state queried.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/simulation_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Running simulations and querying their state and properties — simulation_functions","text":"","code":"simulation_transmissiontime(sim)  simulation_resettime(sim)  simulation_network(sim)  simulation_graph(sim)  simulation_options(sim)  simulation_isinfected(sim, nodes)  simulation_ninfected(sim)  simulation_addinfections(sim, nodes, times)"},{"path":"https://oist.github.io/NEXTNetR/reference/simulation_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Running simulations and querying their state and properties — simulation_functions","text":"sim simulation object","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/simulation_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Running simulations and querying their state and properties — simulation_functions","text":"simulation_transmissiontime(sim) return transmission time distribution simulation_resettime(sim) return reset/recovery time distribution simulation_network(sim) return network. Previusly called simulation_graph. simulation_options(sim) return algorithm options specified simulation created simulation_isinfected(sim, nodes) returns boolen vector (length nodes) containing true node infected simulation_ninfected(sim) returns current number infected nodes simulation_addinfections(sim, nodes, times) markes nodes nodes infected specific times times simulation_run(sim, stop, opts) runs simulation, see simulation_run details","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/simulation_run.html","id":null,"dir":"Reference","previous_headings":"","what":"Runs a simulation until a stopping condition occurs — simulation_run","title":"Runs a simulation until a stopping condition occurs — simulation_run","text":"Runs specified simulation stopping condition occurs returns table listing events occurred. simulation_run can called repeatedly continue point last run stopped. Note epidemic start, initially infected nodes must defined simulation_addinfections.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/simulation_run.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Runs a simulation until a stopping condition occurs — simulation_run","text":"","code":"simulation_run(sim, stop, opts = list())"},{"path":"https://oist.github.io/NEXTNetR/reference/simulation_run.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Runs a simulation until a stopping condition occurs — simulation_run","text":"sim simulation object stop list stopping conditions opts return value options","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/simulation_run.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Runs a simulation until a stopping condition occurs — simulation_run","text":"data.frame containing columns time: time since start simulation epidemic_step: total number epidemic events far network_step: total number network events far kind: kind event (outside_infection, infection, reset, neighbour_added, neibhour_removed, instantenous_contact) node: node affected event neighbour: neighbour (infection, neighbour_added, neibhour_removed) total_infected: total number infected nodes since simulations start total_reset: total number recovered/reset nodes since simulation start infected: current number infected nodes","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/simulation_run.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Runs a simulation until a stopping condition occurs — simulation_run","text":"Stopping conditions specified named list threshold values combination following variables: epidemic_steps: Number epidemic events (infection, outside_infection, reset) since simulation started. network_steps:  Number network events (edge added, edge removed, instantaneous contact) since simulation started. relevant simulations dynamic networks. time:           time since simulation started infected:       Number currently infected nodes total_infected: Total number infections since start simulation total_reset:    Total number recoveries/resets since start simulation Possible return value options : network_events: Include network events returned data.frame. Default false epidemic_events: Include epidemic events returned data.frame. Default true","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/simulation_run.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Runs a simulation until a stopping condition occurs — simulation_run","text":"","code":"# Create contact network network nw <- erdos_renyi_network(1e5, 5) # Create transmission and reset time distributions psi <- lognormal_time(6, 30, 0.1) rho <- weibull_time(shape=5, scale=50) # Create simulation and specifiy initial set of infections sim <- simulation(nw, psi, rho) simulation_addinfections(sim, nodes=c(1), times=c(0.0)) # Run simulation until time t=100 or 200,000 infections have occured r <- simulation_run(sim, stop=list(time=300, total_infected=300e3)) # Plot the number of infected nodes against time plot(r$time, r$infected, type='l')"},{"path":"https://oist.github.io/NEXTNetR/reference/simulation_step.html","id":null,"dir":"Reference","previous_headings":"","what":"Outdated version of simulation_run — simulation_step","title":"Outdated version of simulation_run — simulation_step","text":"compatibility wrapper simulation_run.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/simulation_step.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outdated version of simulation_run — simulation_step","text":"","code":"simulation_step(sim_, steps, opts = list())"},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/sirx_temporalnetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Network SIRX model — sirx_temporalnetwork","title":"Network SIRX model — sirx_temporalnetwork","text":"temporal network implements network version SIRX model introduced well-mixed populations Maier & Brockmann. Starting arbitrary network, nodes removed baseline rate \\(\\kappa_0\\) infected nodes removed elevated rate \\(\\kappa_0 + \\kappa\\), see Maier & Brockmann 2020, Science 368 (6492), 742-74 detais.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/sirx_temporalnetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Network SIRX model — sirx_temporalnetwork","text":"","code":"sirx_temporalnetwork(network, kappa0, kappa)"},{"path":"https://oist.github.io/NEXTNetR/reference/sirx_temporalnetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Network SIRX model — sirx_temporalnetwork","text":"network base network. must simple (.e. self-edges multi-edges). kappa0 \\(\\kappa_0\\) kappa \\(\\kappa\\)","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/time_distributions.html","id":null,"dir":"Reference","previous_headings":"","what":"Creating time distributions — time_distributions","title":"Creating time distributions — time_distributions","text":"NEXTNetR supports series pre-defined distributions transmission recover/reset time, also allows custom distributions defined userdefined_time. exponential_time, lognormal_time, gamma_time, weibull_time names reflect shape transmission time density. Except exponential_time, distributions two parameters, parametrized mean variance. additional parameter \\(p_\\infty\\) adds infinite times possible outcome specified probability, .e scales density \\(1-p_\\infty\\) longer normalized. Instead transmission time density, time distributions can alternatively thought defined infectiousness function \\(\\lambda(\\tau)\\), case polynomial_rate_time infectiousness_time. case, \\(p_\\infty\\) implicity defined \\(\\lambda(\\tau)\\). See discussion time_functions two represenations related. time_distribution object actually represents two-parameer family distributions, see time_functions full discussion functions operate time distribution objects.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/time_distributions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creating time distributions — time_distributions","text":"","code":"exponential_time(lambda, p_infinity = 0)  lognormal_time(mean, var, p_infinity = 0)  gamma_time(mean, var, p_infinity = 0)  weibull_time(shape, scale, p_infinity = 0)  polynomial_rate_time(coeffs)  infectiousness_time(tau, lambda)  deterministic_time(tau)"},{"path":"https://oist.github.io/NEXTNetR/reference/time_distributions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creating time distributions — time_distributions","text":"exponential_time(lambda, p_infinity). Returns time distribution representing exponential distribution rate lambda addition finite values produces value infinity probability p_infinity. represents case constant infectiousness \\(\\lambda(\\tau)=\\lambda\\). lognormal_time(mean, var, p_infinity). Returns time distribution representing Log-normal distribution given mean variance, addition finite  values produces value infinity probability p_infinity. gamma_time(mean, var, p_infinity). Returns time distribution representing Gamma distribution given mean variance, addition finite  values produces value infinity probability p_infinity. weibull_time(mean, var, p_infinity). Returns time distribution representing Weibull distribution given shape scale parameter, addition finite  values produces value infinity probability p_infinity. distribution mean \\(b \\Gamma(1 + 1/)\\) variance \\(b^2(\\Gamma(1 + 2/) - \\Gamma^2(1 + 1/))\\)shape \\(\\) scale \\(b\\). polynomial_rate_time(coeffs). Distribution survival function \\(\\Psi(\\tau) = e^{-p(\\tau)}\\) polynomial infectiousness (hazard rate) \\(p = c[1] + c[2] x + c[3] x^2 + \\ldots\\) non-negative coefficients. infectiousness_time(tau, lambda). Distribution defined term infectiousness function \\(\\lambda(\\tau)\\) specified discrete points \\(\\tau_i, \\lambda_i=\\lambda(\\tau_i)\\) vectors tau lambda. vectors must length non-empty. specified points, \\(\\lambda(\\tau)\\) interpolated linearly. largest specified \\(\\tau_i\\), infectiousness \\(\\lambda(\\tau)\\) assumed constant. deterministic_time(tau). Deterministic time fixed value tau","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/time_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Functions that operate on transmission/recovery/reset time distributions — time_functions","title":"Functions that operate on transmission/recovery/reset time distributions — time_functions","text":"Time distribution objects used specify distribution transmission recovery/reset times. principle, time distribution can represent distribution \\([0,\\infty]\\), value \\(\\infty\\) indicates transmission respectively recovery/reset takes place. See time_distributions functions create objects representing common time distributions lognormal, gamma, etc. time distribution object actually represents two-parameter family distributions parameters \\(t\\) \\(m\\), see Details full discussion.","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/time_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functions that operate on transmission/recovery/reset time distributions — time_functions","text":"","code":"time_sample(n, timedistribution, t = 0, m = 1)  time_density(timedistribution, tau, t = 0, m = 1)  time_hazardrate(timedistribution, tau)  time_survivalprobability(timedistribution, tau, t = 0, m = 1)  time_survivalquantile(timedistribution, p, t = 0, m = 1)"},{"path":"https://oist.github.io/NEXTNetR/reference/time_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functions that operate on transmission/recovery/reset time distributions — time_functions","text":"n number samples draw timedistribution time_distribution. t conditioning time, see details m multiplicity, see details tau non-negative time","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/time_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functions that operate on transmission/recovery/reset time distributions — time_functions","text":"time_sample(n, timedistribution, t, m). Samples n values distribution \\(\\Psi_{t,m}\\). time_density(timedistribution, tau, t, m). Evaluates density points tau distribution \\(\\Psi_{t,m}\\). time_hazardrate(timedistribution, tau). Evaluates hazardrate (infectiousness) \\(\\lambda(\\tau)\\) base distribution \\(\\Psi\\). hazard rate \\(\\Psi_{t,m}\\) simply \\(m\\lambda(t+\\tau)\\), see Details. time_survivalprobability(timedistribution, tau, t, m). Evaluates survivalfunction \\(\\Psi_{t,m}\\) points tau. time_survivalquantile(timedistribution, p, t, m). Computes \\(p\\)-quantiles distribution \\(\\Psi_{t,m}\\).","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/time_functions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functions that operate on transmission/recovery/reset time distributions — time_functions","text":"time distribution object actually represents two-parameter family distributions parameters \\(t\\) \\(m\\). family defined terms base distribution survival function \\(\\Psi(\\tau) = \\exp\\big(-\\int_0^\\tau \\lambda(t) dt\\big)\\). Note assuming form survival function restrict choice base distributions; distribution \\([0,\\infty]\\) takes form \\(\\lambda(\\tau) := -\\Psi'(\\tau) / \\Psi(\\tau)\\). \\(\\lambda(\\tau)\\) called hazard rate infectiousness time \\(\\tau\\). terms hazard rate \\(\\lambda(\\tau)\\), distribution \\(\\Psi(\\tau)\\) naturally interpreted time first event fired inhomogeneous Poisson process rate function \\(\\lambda(\\tau)\\). \\(\\int_0^\\tau \\lambda(t) dt = \\Lambda < \\infty\\) \\(\\tau\\), process necessarily fire distribution takes value \\(\\infty\\) positive probability \\(p_\\infty = e^{-\\Lambda}\\). Parameter \\(m\\) modulates rate function \\(\\lambda(\\tau)\\), parameter \\(t\\) conditions process fire time \\(t\\). Note conditioned distributions, \\(\\tau\\) expressed relative \\(t\\), .e. domain \\(\\tau\\) always \\([0,\\infty]\\). survival function modulates conditioned distribution \\(\\Psi_{t,m}(\\tau) = \\exp\\big(-\\int_t^{t+\\tau} m \\lambda(t) dt\\big)\\). integral \\(m\\), modulation can interpreted taking minimum \\(m\\) ..d. copies unmodulated distribution. used simulation algorithms efficiently handle nodes large numbers edges. Parameter \\(m\\) also used simulating weighted networks, represents weight edge.","code":""},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/userdefined_time.html","id":null,"dir":"Reference","previous_headings":"","what":"User-defined time distributions — userdefined_time","title":"User-defined time distributions — userdefined_time","text":"TODO","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/userdefined_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"User-defined time distributions — userdefined_time","text":"","code":"userdefined_time(   survival,   density,   sample = NULL,   quantile = NULL,   survival_nargs,   sample_nargs = NULL,   quantile_nargs = NULL,   p_infinity )"},{"path":[]},{"path":"https://oist.github.io/NEXTNetR/reference/wattsstrogatz_network.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an Watts-Strogatz network — wattsstrogatz_network","title":"Create an Watts-Strogatz network — wattsstrogatz_network","text":"Create Watts-Strogatz  network given size parameters \\(k\\), \\(p\\)","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/wattsstrogatz_network.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an Watts-Strogatz network — wattsstrogatz_network","text":"","code":"wattsstrogatz_network(size, k, p)"},{"path":"https://oist.github.io/NEXTNetR/reference/wattsstrogatz_network.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an Watts-Strogatz network — wattsstrogatz_network","text":"size number nodes network k parameter k p parameter p","code":""},{"path":"https://oist.github.io/NEXTNetR/reference/wattsstrogatz_network.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an Watts-Strogatz network — wattsstrogatz_network","text":"network object","code":""},{"path":[]}]
